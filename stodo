#!/bin/env python
# -*- coding: UTF-8 -*-

"""
    stodo - a simple CLI todo application
    Copyright (C) 2013 Michał Walczak <mw@michalwalczak.eu>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.
    If not, see <http://opensource.org/licenses/GPL-3.0>.
"""

import sys
import os
import getopt

# globals
ver = "1.0.2"
database = os.path.expanduser("~/.stodo") # path of the database file

def usage():
    """Print help/usage information."""
    print("Usage: stodo OPTION [ARGUMENT]")
    print("Only the first option on the command line will execute each run.")
    print("Mandatory arguments to long versions are mandatory for short versions too.")
    print("   -h, --help\t\tprint usage summary (this)")
    print("   -l, --list\t\tlist all of the saved items, enumerated")
    print("   -c, --count\t\tprint a simple count of all saved items")
    print("   -a, --add \"item\"\tadd text between quotes as a new item")
    print("   -r, --remove (1...n)\tremove the specified item")
    print("   -v, --version\tshow version and license information")
    print("Please report bugs and send developement suggestions to <mw@michalwalczak.eu>")

def version():
    """Print version and license information."""
    print("stodo - simple TODO CLI application " + ver)
    print("Copyright (C) 2013 Michał Walczak <mw@michalwalczak.eu>")
    print("License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.")
    print("This is free software: you are free to change and redistribute it.")
    print("There is NO WARRANTY, to the extent permitted by law.")

def file_exists():
    """Check if the database file exists and attempt to create it if it doesn't."""
    try:
        data_file = open( database, "a+");
    except IOError:
        print("Error: Database file not found, and cannot be created.")
        print("Make sure you have write and read access to the folder (user's home folder by default).")
        sys.exit(2)

    data_file.close()

def count_items():
    """"Count items stored on the list, return it."""
    file_exists()

    with open(database) as data_file:
        i = - 1 #start from -1 so 0 items will display correctly
        for i, l in enumerate(data_file): #counting
            pass
        return i + 1

    data_file.close()

def display_list():
    """Display a list of all items stored on the user's database, line by line."""
    file_exists()

    if count_items() == 0:
        print("No items on the list.")
        return 0

    data_file = open( database, "r")
    s = "" #read file lines into one string
    for i in range(count_items()):
        s += (data_file.readline())

    print(s.rstrip()) #remove the trailing newline (print ends output with '\n')

    data_file.close()

def display_count():
    """Take count_items()'s value and print the result."""
    file_exists()

    print(count_items())

def add_item(add_string):
    """Adds an item to the database."""
    file_exists()

    # determine the next id for an item via checking the highest one
    if count_items() != 0:
        lines = [line.rstrip('\n') for line in open(database)]
        highest_number = [token for token in lines[len(lines)-1].split() if token.isdigit()][0]
        highest_number = int(highest_number)+1
    else:
        highest_number = 1
    
    # replace the newlines in the added string with spaces
    add_string = add_string.replace('\n', ' ')

    # append the new item at the end of the database file
    data_file = open( database, "a+")
    data_file.write(str(highest_number) + "\t-\t" + add_string + "\n")
    data_file.close()

def remove_item(remove_number):
    """Removes an item determined by it's id (not line it's on)."""
    file_exists()

    lines = [line.rstrip('\n') for line in open(database)] # read all lines
    item_number = 0
    removed_item = 0
    for line in lines: # find the removed item and pop it out of the list
        item_number = [token for token in line.split() if token.isdigit()][0]
        if item_number == remove_number:
            removed_item = lines.pop(lines.index(line))
            break

    # write all the remaining lines back in
    if removed_item != 0:
        data_file = open( database, "w")
        for line in lines:
            data_file.write(line + "\n")
        data_file.close()
        # print the removed line
        print("Item *" + removed_item + "* has been removed.")
    else:
        print("No item number ", remove_number, "found.")

def main(argv):
    """Main function, executes the first valid option and terminates."""
    try:
        opts, args = getopt.getopt(argv, "hvlca:r:", ["help", "version", "list", "count", "add=", "remove="])

    except getopt.GetoptError: # unknown option found
        usage() # print usage info
        sys.exit(2)

    if len(opts) == 0: # no options specified
        usage() # print usage info
        sys.exit()

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()
            sys.exit()
        elif opt in ("-v", "--version"):
            version()
            sys.exit()
        elif opt in ("-l", "--list"):
            display_list()
            sys.exit()
        elif opt in ("-c", "--count"):
            display_count()
            sys.exit()
        elif opt in ("-a", "--add"):
            add_item(arg)
            sys.exit()
        elif opt in ("-r", "--remove"):
            if arg.isdigit():
                remove_item(arg)
                sys.exit()
            else:
                print("-r / --remove accepts only natural numbers, -h or --help for usage")
                sys.exit()

if __name__ == "__main__":
    main(sys.argv[1:]) # run the main function, turncate the script name from arguments
else:
    print("stodo is not ment to be ran as an imported module.")